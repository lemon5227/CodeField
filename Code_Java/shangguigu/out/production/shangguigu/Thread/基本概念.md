#程序
为完成特定任务，用某种语言编写的一组指令的集合
。即一段静态的代码，静态队形。
#进程（process）
程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：
它有自身的产生，存在和消亡的过程。——————生命周期
1. 如：运行中的QQ，运行中的MP3播放器
2. 程序是静态的，进程是动态的
3. 进程作为分配资源的单位，系统在运行时为每个进程分配不同的内存区域
#线程（thread）
进程可进一步细化为线程，是一个程序内部的一条执行路径。
1. 若一个进程同一时间执行多个线程，就是支持多线程的
2. 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。
3. 一个进程的多个线程共享相同的内存单元，好处是线程通信简便、高效。坏处是带来安全的隐患
#单核CPU和多核CPU 
1. 单核CPU,是假的多线程，因为CPU时间单元特别短，因此感觉不出来
2. 多核的才能好的发货多线程的效率。
3. 一个Java.exe，其实至少有三个线程：main（）主线程，gc()垃圾回收线程，异常处理线程。如果发生一次会影响主线程
#并行与并发
1. 并行：多个CPU同时执行多个任务。比如多个人同时做不同的事。
2. 并发：一个CPU（采用时间片）同时执行多个任务。比如：秒杀，多个人做同一件事。
#使用多线程的有点
1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2. 提高计算机系统CPU利用率
3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。
#何时需要多线程
1. 程序需要执行两个或多个任务
2. 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜素等。
3. 需要一些后台运行的程序时。
#解决线程安全问题
1. 方式一：同步代码块
synchronized(同步监视器){
   //需要被同步的代码
}
说明：1.操作共享数据的代码，即为需要被同步的代码
     2.共享数据：多个线程共同操作的变量。比如ticket就是共享数据
     3.同步监视器,俗称：锁。任何一个类的对象，都可以充当锁。
        要求：多个线程必须要共用同一把锁
2. 方法二：同步方法
   如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法同步的
    1.同步方法仍然涉及到同步监视器，只是不需要我们现实的声明
    2. 非静态的同步方法，同步监视器是:this is
        静态的同步方法，同步监视器是：当前类本身

   同步的方法,解决了线程的安全问题 --- 好处
操作同步代码时，相当于单线程。
3. Lock锁---jdk5.0新增

**实现的内部，天然的是同一把锁，继承里面锁需要加static来保证是同一把锁。**
#死锁
1.不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
2.出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
### 解决方法
1.专门的算法、原则
2.尽量减少同步资源的定义
3.尽量避免嵌套同步
# Lock（锁）
1. JDK5加入的更强大的线程同步机制——通过现实的定义同步锁对象来实现同步。同步锁使用Lock对象充当
2. **java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具**。锁提供了对共享资源的独占
访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。
3. ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的
控制中，比较常用的是ReentrantLock，可以显式加锁，释放锁。
#JDK5.0新增的线程创建方式
新增方式一：实现Callable接口，相比Runnable，Callable功能更强大
1.相比run()方法，可以有返回值
2.方法可以抛出异常
3.支持泛型的返回值
4.需要借助FutureTask类，比如获取返回结果
2021-12-10 444集跳到450集
